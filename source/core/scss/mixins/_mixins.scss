// -------------------------------------- //
// LogoType速: Advance CSS3: Cross Browser //
// -------------------------------------- //
//         Using @mixin directive         //
//                  ~   ~                 //
//                 (.) (.)                //
//                    -                   //
//                  `\^/`                 //
//        @author : Prabhat Kumar         //
//          @date : 11-May-2016           //
// -------------------------------------- //
// Sass - (3.4.21)     : Selective Steve  //
// Compass - (v1.0.3)  : Polaris          //
// -------------------------------------- //

// Path: logotype/source/core/scss/mixins/

// ==========================================
// B. Visually hide an element.
%visuallyhidden {
  margin: -1px;
  padding: 0;
  width: 1px;
  height: 1px;
  overflow: hidden;
  clip: rect(0 0 0 0);
  clip: rect(0, 0, 0, 0);
  position: absolute;
}

// ==========================================
// C. CSS3 calc mixin.
@mixin axix-calc($property, $value) {
  #{$property}: -webkit-calc(#{$value});
  #{$property}: -moz-calc(#{$value});
  #{$property}: calc(#{$value});
}

// ==========================================
// D. Mixins for semi-transparent colors.
// D-1
@mixin alpha-background-color($color, $background) {
  $percent: alpha($color) * 100%;
  $opaque: opacify($color, 1);
  $solid-color: mix($opaque, $background, $percent);
  background-color: $solid-color;
  background-color: $color;
}

// D-2
@mixin alpha-attribute($attribute, $color, $background) {
  $percent: alpha($color) * 100%;
  $opaque: opacify($color, 1);
  $solid-color: mix($opaque, $background, $percent);
  #{$attribute}: $solid-color;
  #{$attribute}: $color;
}

// ==========================================
// E. The @function directive to strip unit.
@function strip-unit($value) {
  @return $value / ($value * 0 + 1);
}

// ==========================================
// F. The @function directive to clamp a number.
// Clamping a number means restricting it between min and max values.
// Usage:
// 1. If the value is greater than the maximum value, it returns $max
// 2. If the value is lesser than or equals to the maximum value and
//  - if the value is lesser than the minimum value, it returns $min
//  - if the value is greater than or equals to the minimum value, it returns $value
@function clamp($value, $min, $max) {
  @return if($value > $max, $max, if($value < $min, $min, $value));
}

// ==========================================
// G. The @function directive for px to em string interpolation.
// @using Sass unitless() method.
$browser-context: 16;

@function em($pixels, $context: $browser-context) {
  @if (unitless($pixels)) {
    $pixels: $pixels * 1px;
  }
  
  @if (unitless($context)) {
    $context: $context * 1px;
  }
  
  @return $pixels / $context * 1em;
}

// ==========================================
// H. The @mixin directive for IE-7.
// @Using: @content directive.
@mixin apply-to-ie7 {
  // IE7 hack from -->
  // http://www.paulirish.com/2009/browser-specific-css-hacks/
  *:first-child+html & {
    @content;
  }
}

// ==========================================
// I. The @mixin directive for ::selection.
// The ::selection CSS pseudo-element applies rules to the portion of a document,
// that has been highlighted (e.g. selected with the mouse or another pointing device) by the user.
/// Note: Only a small subset of CSS properties can be used in a rule using ::selection in it's
/// selector: color, background-color, cursor, outline, text-decoration, text-emphasis-color and text-shadow.
@mixin axix-selection ($background, $color) {
  background: $background;
  color: $color;
}

// ============================================
// J. The @mixin directive for Size -->
//                             (width & height)
@mixin axix-size($width, $height: $width) {
  width: $width;
  height: $height;
}

// ============================================
// K. The @mixin directive to Centering.
// Horizontal, Vertical or Absolute Centering:
/// If specified, this mixin will use negative margins
/// based on element's dimensions. Else, it will rely
/// on CSS transforms which have a lesser browser support
/// but are more flexible as they don't require to set,
/// any specific dimensions to the element.
/// It accepts parameter(s):
/// @param {Length | null} $width [null] - element width.
/// @param {Length | null} $height [null] - element height.
@mixin translate($x, $y) {
  -webkit-transform: translate($x, $y);
     -moz-transform: translate($x, $y);
      -ms-transform: translate($x, $y);
       -o-transform: translate($x, $y);
          transform: translate($x, $y);
}

@mixin translateY($y) {
  -webkit-transform: translateY($y);
     -moz-transform: translateY($y);
      -ms-transform: translateY($y);
       -o-transform: translateY($y);
          transform: translateY($y);
}

@mixin translateX($x) {
  -webkit-transform: translateX($x);
     -moz-transform: translateX($x);
      -ms-transform: translateX($x);
       -o-transform: translateX($x);
          transform: translateX($x);
}

@mixin axix-center($width: null, $height: null) {
  position: absolute;
  top: 50%;
  left: 50%;
  
  @if not $width and not $height {
    // To transform: translate(-50%, -50%).
    @include translate(-50%, -50%);
  } @else if $width and $height {
    width: $width;
    height: $height;
    margin: -($width / 2) #{0 0} -($height / 2)
  } @else if not $height {
    margin-left: -($width / 2);
    // To transform: translateY(-50%).
    @include translateY(-50%);
    width: $width;
  } @else {
    margin-top: -($height / 2);
    // To transform: translateX(-50%).
    @include translateX(-50%);
    height: $height;
  }
}

// ============================================
// L. Mixin helper to output vendor prefixes.
// @param {String} $property - Unprefixed CSS property
// @param {*} $value - Raw CSS value
// @param {List} $prefixes - List of prefixes to output
@mixin axix-prefix($property, $value, $prefixes: ()) {
  @each $prefix in $prefixes {
    -#{$prefix}-#{$property}: $value;
  }
  #{$property}: $value;
}

// ============================================
// M. The @mixin directive for Linear Gradient.
/// Convert angle
/// @param {Number} $value - Value to convert,
/// @param {String} $unit - Unit to convert to,
/// @return {Number} Converted angle.
@function convert-angle($value, $unit) {
  $convertable-units: deg grad turn rad;
  $conversion-factors: 1 (10grad/9deg) (1turn/360deg) (3.1415926rad/180deg);
  @if index($convertable-units, unit($value)) and index($convertable-units, $unit) {
    @return $value
             / nth($conversion-factors, index($convertable-units, unit($value)))
             * nth($conversion-factors, index($convertable-units, $unit));
  }
  // for warning message!
  @warn "AXIX速: Cannot convert `#{unit($value)}` to `#{$unit}`.";
}

/// Test if `$value` is an angle.
/// @param {*} $value - Value to test,
/// @return {Bool}
@function is-direction($value) {
  $is-direction: index((to top, to top right, to right top, to right, to bottom right, to right bottom, to bottom, to bottom left, to left bottom, to left, to left top, to top left), $value);
  $is-angle: type-of($value) == 'number' and index('deg' 'grad' 'turn' 'rad', unit($value));
  @return $is-direction or $is-angle;
}

/// Convert a direction to legacy syntax.
/// @param {Keyword | Angle} $value - Value to convert,
/// @require {function} is-direction
/// @require {function} convert-angle
@function legacy-direction($value) {
  @if is-direction($value) == false {
    // for warning message!
    @warn "AXIX速: Cannot convert `#{$value}` to legacy syntax because it doesn't seem to be an angle or a direction.";
  }
  // Conversion Map.
  $conversion-map: (
    to top          : bottom,
    to top right    : bottom left,
    to right top    : left bottom,
    to right        : left,
    to bottom right : top left,
    to right bottom : left top,
    to bottom       : top,
    to bottom left  : top right,
    to left bottom  : right top,
    to left         : right,
    to left top     : right bottom,
    to top left     : bottom right
  );
  @if map-has-key($conversion-map, $value) {
    @return map-get($conversion-map, $value);
  }
  @return 90deg - convert-angle($value, 'deg');
}

/// Mixin printing a linear-gradient.
/// as well as a plain color fallback,
/// and the `-webkit-`, `-moz-`, `-ms-` and `-o-` prefixed declaration.
/// @access public
/// @param {String | List | Angle} $direction - Linear gradient direction
/// @param {Arglist} $color-stops - List of color-stops composing the gradient.
@mixin linear-gradient($direction, $color-stops...) {
  @if is-direction($direction) == false {
    $color-stops: ($direction, $color-stops);
    $direction: 180deg;
  }
  background: nth(nth($color-stops, 1), 1);
  background: -webkit-linear-gradient(legacy-direction($direction), $color-stops);
  background: -moz-linear-gradient(legacy-direction($direction), $color-stops);
  background: -ms-linear-gradient(legacy-direction($direction), $color-stops);
  background: -o-linear-gradient(legacy-direction($direction), $color-stops);
  background: linear-gradient($direction, $color-stops);
}

// ============================================
// N. The @mixin directive for ultimate mixin.
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 1. Modernizr ultimate mixin:
//  1.1 Generate placholder name and selectors
//  1.2 Define placholder and print @content
//  1.3 Define feature selector and
//      extend the placeholder.
// 2. Aliases:
//  2.1 Yep - alias
//  2.2 Nope - alias
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/// Usage:
/// .selector {
///   @include yep($features) { ... }
///   @include nope($features) { ... }
/// }
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 1. Modernizr mixin defined.
// ============================================
@mixin modernizr($features, $supports) {
  $everything-is-okay: true;
  // Use the 'no-' prefix if checking for unsuported features (e.g. `.no-translate3d`).
  $prefix: if($supports, '', 'no-');
  // Features selector:
  /// a) create a string if checking for supported features. We'll concatenate class names
  ///     later on (e.g. `.translate3d.opacity selector`),
  /// b) create a list if checking for unsuported features. We'll append the class names
  ///     later on (e.g. `.no-js selector, .no-translate3d selector`).
  $selector: if($supports, '', (unquote('.no-js')));
  // The placeholder (e.g. `%yep-translate3d` or `%nope-opacity`).
  $placeholder: if($supports, '%yep', '%nope');
  
  // 1.1 Generate placeholder and selectors
  // ======================================
  @each $feature in $features {
    // Making sure $feature is a string.
    @if type-of($feature) != string {
      $everything-is-okay: false;
      @warn 'AXIX速: `#{$feature} is not a string for `modernizr`.';
    } @else {
      // Add feature name to the placeholder string (e.g. '%yep' + '-' + 'translate3d' or '%nope' + '-' + 'translate3d').
      $placeholder: $placeholder + '-' + $feature;
      // Define the new selector string (e.g. `.translate3d` or `.no-translate3d`).
      $new-selector: #{'.' + $prefix + $feature};
      // Append the new selector:
      /// a) to the string if yep (e.g. `.translate3d.opacity`),
      /// b) to the list if nope (e.g. `.no-translate3d, .no-opacity`).
      $selector: if($supports, $selector + $new-selector, append($selector, $new-selector, comma));
    }
  }
  @if $everything-is-okay == true {
    // 1.2 Define the placholder and print @content
    // ============================================
    #{$placeholder} & {
      @content;
    }
    // 1.3 Define feature selector(s) and extend the placeholder
    // =========================================================
    @at-root #{$selector} {
      @extend #{$placeholder};
    }
  }
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 2. Aliases
// ============================================
// 2.1 Yep - alias
// ===============
@mixin yep($features...) {
  @include modernizr($features, $supports: true) {
    @content;
  }
}
// 2.2 Nope - alias
// ================
@mixin nope($features...) {
  @include modernizr($features, $supports: false) {
    @content;
  }
}

// ============================================
// O. A smart cache @mixin directive.
//    @author : Prabhat Kumar
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Global cache map.
$cache: ();

// Cache mixin.
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@mixin cache($declarations) {
  // Looping through all properties/values from map.
  @each $property, $value in $declarations {
    // Get the stored values for the current property.
    $stored-values: map-get($cache, $property);
    // If the value doesn't exist in stored values.
    @if not index($stored-values, $value) {
      // Add it.
      $cache: map-merge($cache, ($property: append($stored-values or (), $value))) !global;
      // And create a placeholder at root level.
      @at-root %#{$property}-#{length(map-get($cache, $property))} {
        #{$property}: $value;
      }
    }
    // Extend the placeholder.
    @extend %#{$property}-#{index(map-get($cache, $property), $value)};
  }
}
